{% extends "timelockrecovery/components/timelockrecovery_tab.jinja" %}
{% set tab = 'index' %}

{% block content %}
    <div id="tx-popup" class="hidden"></div>

	{% include "includes/qr-scanner.html" %}
	{% include "includes/recipient-box.html" %}
	{% include "timelockrecovery/includes/timelockrecovery-fee-selection.html" %}

	<form action="{{ url_for('wallets_endpoint.send_new',wallet_alias=wallet_alias) }}" id="send-form" method="POST" data-style="width: 100%;">
		<h2>Step 2: Prepare Alert and Recovery transactions for wallet {{ wallet.name }}</h2>

		<div class="flex flex-col">
			<p>
				{{ _("Available funds before Alert transaction:") }} {{wallet.amount_available | btcunitamount}}
				{% if specter.unit == 'sat' %}sats{% else %}{% if specter.is_testnet %}t{%endif%}BTC{% endif %}

				{% if specter.price_check %}
					<span>{{ wallet.amount_available | altunit }}</span>
				{% endif %}
			</p>

			{% if wallet.amount_locked_unsigned  > 0 or wallet.amount_frozen > 0 %}
				<div>
					<tool-tip width="150px">
							<h4 slot="title">{{ _("Why is this less than my total balance?") }}</h4>
							<span slot="paragraph">
							{{ _(' Frozen outputs and outputs locked in unsigned transactions are not available here.
							To make more funds available, click on the "Unsigned" tab and delete not required transactions or unfreeze UTXO under "Transactions".') }}
							</span>
					</tool-tip>
				</div>
			{% endif %}

			<p id="alert-psbt-loading">&nbsp;</p>

			<p id="alert-psbt-creation-fail" class="warning hidden">
				Cannot create Alert transaction.
				<span id="alert-psbt-creation-fail-reason"></span>
			</p>

			<p id="alert-psbt-api-fail" class="warning hidden">
				Cannot create Alert transaction due to a communication error or session expiration.
			</p>

			<p id="alert-psbt-success" class="hidden">
				{{ _("Available funds after Alert transaction:") }}
				<span id="available-funds-after-alert"></span>
			</p>

		</div>

		<div class="flex flex-col">
			<div id="recipients" class="mt-3 rounded-t-xl overflow-hidden recipient_wrapper">
				<div class="recipient_wrapper_item">
					<div class="px-4 py-3 flex bg-dark-700">
						<div class="icon-info">
							<img class="svg-selftransfer" src="{{ url_for('static', filename='img') }}/transfer.svg" style="height: 1.75rem;" />
							<p class="icon-info-text">Self Transfer</p>
						</div>
						<span class="text-lg pl-1">Alert Address (in wallet {{ wallet.name }})</span>
					</div>
					<div class="recipient_wrapper_inner_box px-3 py-3 space-y-3 border-l-2 border-r-2 border-dark-700">
						<div class="flex space-x-3">
							<div class="floating-wrapper grow-[3]">
								<input class="floating-input peer" type="text" name="alert_address" value="{{ reserved_address.address }}" placeholder=" " disabled />
								<label class="floating-label" id="addressInputLabel">Alert Address</label>
							</div>
							<div class="floating-wrapper grow-[1]">
								<input class="floating-input peer" type="text" class="address-label" name="alert_label" value="{{ reserved_address.label }}" placeholder=" " disabled />
								<label class="floating-label">Address Label</label>
							</div>
						</div>
					</div>
				</div>
			</div>

			<div
				class="px-4 py-3 cursor-pointer hover:bg-dark-700 rounded-b-xl bg-dark-600 text-white mb-2"
				id="add-recipient"
				title="Add a recipient"
				class="recipient_button recipient_add"
			>
				+ Add Recipient
			</div>
		</div>

        <div>
            <h3 class="mt-5">Alert Transaction - {{ _("Fee Selection") }}</h3>
            <timelockrecovery-fee-selection id="alert-transaction-fee-selection-component"></timelockrecovery-fee-selection>
        </div>
	</form>
{% endblock %}

{% block scripts %}
	<script>
        const MIN_FEE_RATE = 1;
        const NETWORK = "Bitcoin";
		const amountAvailable = "{{ wallet.amount_available | btcamount }}";
		const specterUnit = "{% if specter.unit == 'sat' %}sats{% else %}{% if specter.is_testnet %}t{%endif%}BTC{% endif %}";
		const anchorOutputAmountSats = 600;

		let feeSelectionAsyncTracker = 0;

		async function simulateAlertTransaction() {
			const feeSelectionComponent = document.getElementById('alert-transaction-fee-selection-component');
			const selectedFee = feeSelectionComponent.selectedFee();
			feeSelectionAsyncTracker += 1;
			const asyncTracker = feeSelectionAsyncTracker;
			try {
				document.getElementById('alert-psbt-success').classList.add('hidden');
				document.getElementById('alert-psbt-creation-fail').classList.add('hidden');
				document.getElementById('alert-psbt-api-fail').classList.add('hidden');
				document.getElementById('alert-psbt-loading').classList.remove('hidden');
				await new Promise((resolve) => setTimeout(resolve, 400));
				if (asyncTracker !== feeSelectionAsyncTracker) {
					return;
				}
				if (selectedFee === "") {
					return;
				}
				const recipientList = [...document.querySelectorAll('#recipients > recipient-box')];
				if (recipientList.length === 0 || recipientList.some((r) => !validateAddress(r.address))) {
					return;
				}
				const fetchResult = await fetch(
					`{{ url_for(service.id + "_endpoint.create_psbt", wallet_alias=wallet.alias) }}`,
					{
						signal: AbortSignal.timeout(5000),
						method: 'POST',
						headers: {
							'accept': 'application/json',
							'content-type': 'application/json',
							'x-csrftoken': "{{ csrf_token() }}",
						},
						body: JSON.stringify({
							recipients: [
								{
									address: "{{ reserved_address.address }}",
									amount: (Math.round(Number(amountAvailable) * 1e8) - anchorOutputAmountSats * recipientList.length) / 1e8,
									unit: "btc",
									label: "{{ reserved_address.label }}"
								},
								...recipientList.map(({ address, label }) => ({
									address,
									amount: anchorOutputAmountSats / 1e8,
									unit: "btc",
									label,
								})),
							],
							rbf_tx_id: "",
							subtract: true,
							subtract_from: 0,
							fee_rate: selectedFee,
							rbf: feeSelectionComponent.rbfOption.checked,
						}),
					},
				);
				if (!fetchResult.ok) {
					throw new Error("Fetch result not ok");
				}
				const { result, error } = await fetchResult.json();
				if (error) {
					console.error("Fetch call responded with an error", error);
					if (asyncTracker === feeSelectionAsyncTracker) {
						document.getElementById('alert-psbt-creation-fail').classList.remove('hidden');
						document.getElementById('alert-psbt-creation-fail-reason').textContent = psbtFailReason(error);
					}
				} else {
					if (asyncTracker === feeSelectionAsyncTracker) {
						document.getElementById('available-funds-after-alert').textContent = specterUnit === 'sats' ? `${result.outputs[0].sat_amount} sats` : `${result.outputs[0].float_amount} ${specterUnit}`;
						document.getElementById(`alert-psbt-success`).classList.remove('hidden');
					}
				}
			} catch (err) {
				console.error("Failed to calculate recovery-transaction available funds", err);
				if (asyncTracker === feeSelectionAsyncTracker) {
					document.getElementById('alert-psbt-api-fail').classList.remove('hidden');
				}
			}
			if (asyncTracker === feeSelectionAsyncTracker) {
				document.getElementById('alert-psbt-loading').classList.add('hidden');
			}
		};

		function psbtFailReason(error) {
			if (/Invalid\sBitcoin\saddress(:\s\w+)?$/i.test(error)) {
				return "Invalid recipient address.";
			}
			if (/Invalid\sparameter,\sduplicated\saddress(:\s\w+)?$/i.test(error)) {
				return "Duplicated address.";
			}
			if (/:\sInsufficient\sfunds$/i.test(error)) {
				return "Not enough funds for fee."
			}
			if (/:\sInvalid\samount$/i.test(error)) {
				return "Invalid fee or amounts.";
			}
			if (/:\sInvalid\samount$/i.test(error)) {
				return "Invalid fee or amounts.";
			}
			if (/:\sFee\sexceeds\smaximum\sconfigured\sby\suser\s\(e.g.\s-maxtxfee,\smaxfeerate\)$/i.test(error)) {
				return "Fee exceeds maximum configured by user.";
			}
			return "Reason could be recipient addresses, not enough funds or something else.";
		}

		function getRecipientIds() {
			return [...document.querySelectorAll('#recipients > recipient-box')].map((child) => child.recipientId);
		}

		function validateAddress(address, doShowError=false) {
			if (!address) {
				if (doShowError) {
					showError(`{{ _("You provided no address.") }}`, 5000);
				}
				return false;
			}
			// Segwit addresses are always between 14 and 74 characters long.
			if (address.length < 14) {
				if (doShowError) {
					showError(`{{ _("Please provide a valid address!") }}`, 5000);
				}
				return false;
			}
			if (/\s/.test(address)) {
				if (doShowError) {
					showError(`{{ _("Looks like there are whitespaces in the address field.") }}`, 5000);
				}
				return false;
			}
			return true;
		}

		function validateForm() {

		}

		function updateRecipientElementsByPosition(){
			const recipientList = [...document.querySelectorAll('#recipients > recipient-box')];
			const hidden = (recipientList.length <= 1);
			let recipientIndex = 0;
			for (const recipient of recipientList) {
				recipient.hiddenRemoveButton = hidden;
				recipient.title = `Recipient ${recipientIndex + 1}`;
				recipient.amountElement.disabled = false;
				recipientIndex += 1;
			}
			recipientList.slice(-1)[0].amountElement.disabled = true;
		}

		function addRecipient(address, amount, amount_unit, label) {
			for (const someRecipient of document.querySelectorAll('#recipients > recipient-box')) {
				someRecipient.amountElement.disabled = false;
			}

			const recipientIds = getRecipientIds();
			const recipientId = Math.max(-1, ...recipientIds) + 1;

			// This adds the recipient
			const recipients = document.getElementById('recipients');
			const newRecipient = new RecipientBox();
			newRecipient.id = `recipient_${recipientId}`;
			newRecipient.recipientId = recipientId;
			newRecipient.address = address;
			newRecipient.amount = amount;
			newRecipient.unit = amount_unit;
			newRecipient.label = label;
			newRecipient.classList = "group";
			newRecipient.shadowRoot.getElementById('send_max').remove();
			newRecipient.amountElement.disabled = true;
			newRecipient.addEventListener('remove', (event) => {
				removeRecipient(newRecipient.recipientId);
			});
			newRecipient.addressElement.addEventListener('input', (event) => {
				validateForm();
				simulateAlertTransaction();
			});
			newRecipient.labelElement.addEventListener('input', () => {
				simulateAlertTransaction();
			});
			newRecipient.addEventListener('unit-change', (event) => {
				validateForm();
			});

			recipients.appendChild(newRecipient);

			// Make the remove button visible again for all recipient components
			updateRecipientElementsByPosition();
			simulateAlertTransaction();
		}

		function removeRecipient(recipientId) {
			for (const someRecipient of document.querySelectorAll('#recipients > recipient-box')) {
				if (someRecipient.recipientId === recipientId) {
					someRecipient.remove();
				}
			}
			updateRecipientElementsByPosition();
			simulateAlertTransaction();
		}

		document.addEventListener('DOMContentLoaded', () => {
			addRecipient('', '', 'btc', '');
			updateRecipientElementsByPosition();
			document.getElementById('alert-transaction-fee-selection-component').addEventListener('change', simulateAlertTransaction);
			document.getElementById('add-recipient').onclick = () => addRecipient('', '', 'btc', '');
		});
	</script>
{% endblock %}
